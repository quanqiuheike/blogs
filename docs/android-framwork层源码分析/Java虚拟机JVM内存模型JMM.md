# Java虚拟机JVM内存模型JMM

# [JVM内存模式](https://www.cnblogs.com/tangZH/p/15207075.html)



**Java内存模型即Java Memory Model，简称JMM。**

**JMM定义了Java 虚拟机(JVM)在计算机内存(RAM)中的工作方式。JVM 是整个计算机虚拟模型，所以 JMM 是隶属于 JVM 的。**

 ![img](https://img2020.cnblogs.com/blog/1019373/202108/1019373-20210830154712661-1009674662.png)

一、JVM构成：

**1、类加载器**（ClassLoader）**:在 JVM 启动时或者在类运行将需要的 class 加载到JVM 中。

**2、执行引擎**：负责执行 class 文件中包含的字节码指令.

**3、内存区（也叫运行时数据区）**：是在 JVM 运行的时候操作所分配的内存区。

**（1）、方法区(MethodArea)**：用于存储类结构信息的地方，包括常量池、静态常量、构造函数等。虽然 JVM 规范把方法区描述为堆的一个辑部分， 但它却有个别名non-heap（非堆），所以大家不要搞混淆了。方法区还包含一个运行时常量池。

**（2）、java 堆(Heap)**：存储 java 实例或者对象的地方。这块是 GC 的主要区域。从存储的内容我们可以很容易知道，方法和堆是被所有 java 线程共享的。

**（3）、java 栈(Stack)**：java 栈总是和线程关联在一起，每当创一个线程时，JVM 就会为这个线程创建一个对应的 java 栈在这个 java 栈中,其中又会包含多个栈帧，每运行一个方法就建一个栈帧，用于存储局部变量表、操作栈、方法返回等。每一个

**（4）、程序计数器(PCRegister)**：用于保存当前线程执行的内存地址。由于 JVM 程序是多线程执行的（线程轮流切换），所以为了保证程切换回来后，还能恢复到原先状态，就需要一个独立计数器，记录之前中断的地方，可见程序计数器也是线程私有的。

**（5）、本地方法栈(Native MethodStack)**：和 java 栈的作用差不多，只不过是为 JVM 使用到 native 方法服务的。

**4、本地方法接口**：主要是调用 C 或 C++实现的本地方法及回调结果。

**开线程影响哪块内存？**

每当有线程被创建的时候，JVM 就需要为其在内存中分配虚拟机栈和本地方法栈来记录调用方法的内容，分配程序计数器记录指令执行的位置，这样的内存消耗就是创建线程的内存代价。

Java 线程之间的通信总是隐式进行，并且采用的是共享内存模型。这里提到的共享内存模型指的就是 Java 内存模型(简称 JMM)，JMM 决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM 定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是 JMM 的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。总之，JMM 就是一组规则，这组规则意在解决在并发编程可能出现的线程安全问题，并提供了内置解决方案（happen-before 原则）及其外部可使用的同步手段(synchronized/volatile 等)，确保了程序执行在多线程环境中的应有的原子性，可视性及其有序性。