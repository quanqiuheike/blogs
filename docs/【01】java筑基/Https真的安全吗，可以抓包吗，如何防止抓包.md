## 背景

我们知道，http 通信存在以下问题：

- 通信使用明文可能会被窃听
- 不验证通信方的身份可能遭遇伪装
- 无法证明报文的完整型，可能已遭篡改

使用 https 可以解决数据安全问题，但是你真的理解 https 吗？

**当面试官连续对你发出灵魂追问的时候，你能对答如流吗**

1. 什么是 https，为什么需要 https
2. https 的连接过程
3. https 的加密方式是怎样的，对称加密和非对称加密，为什么要这样设计？内容传输为什么要使用对称机密
4. https 是绝对安全的吗
5. https 可以抓包吗

如果你能对答自如，恭喜你，https 你已经掌握得差不多了，足够应付面试了。

## 什么是 https

简单来说， https 是 http + ssl，对 http 通信内容进行加密，是HTTP的安全版，是使用TLS/SSL加密的HTTP协议

Https的作用：

1. 内容加密 建立一个信息安全通道，来保证数据传输的安全；
2. 身份认证 确认网站的真实性
3. 数据完整性 防止内容被第三方冒充或者篡改

### 什么是SSL

SSL 由 Netscape 公司于1994年创建，它旨在通过Web创建安全的Internet通信。它是一种标准协议，用于加密浏览器和服务器之间的通信。它允许通过Internet安全轻松地传输账号密码、银行卡、手机号等私密信息。

SSL证书就是遵守SSL协议，由受信任的CA机构颁发的数字证书。

SSL/TLS的工作原理:

需要理解SSL/TLS的工作原理，我们需要掌握加密算法。加密算法有两种：对称加密和非对称加密：

**对称加密**：通信双方使用相同的密钥进行加密。特点是加密速度快，但是缺点是需要保护好密钥，如果密钥泄露的话，那么加密就会被别人破解。常见的对称加密有AES，DES算法。

**非对称加密**：它需要生成两个密钥：公钥(Public Key)和私钥(Private Key)。

公钥顾名思义是公开的，任何人都可以获得，而私钥是私人保管的。相信大多程序员已经对这种算法很熟悉了：我们提交代码到github的时候，就可以使用SSH key：在本地生成私钥和公钥，私钥放在本地.ssh目录中，公钥放在github网站上，这样每次提交代码，不用麻烦的输入用户名和密码了，github会根据网站上存储的公钥来识别我们的身份。

公钥负责加密，私钥负责解密；或者，私钥负责加密，公钥负责解密。这种加密算法安全性更高，但是计算量相比对称加密大很多，加密和解密都很慢。常见的非对称算法有RSA。

## https 的连接过程

[![img](https://raw.githubusercontent.com/gdutxiaoxu/blog_pic/master/20_04/20200708223003.png)](https://raw.githubusercontent.com/gdutxiaoxu/blog_pic/master/20_04/20200708223003.png)

https 的连接过程大概分为两个阶段，证书验证阶段和数据传输阶段

### 证书验证阶段

大概分为三个步骤

1. 浏览器发起请求
2. 服务器接收到请求之后，会返回证书，包括公钥
3. 浏览器接收到证书之后，会检验证书是否合法，不合法的话，会弹出告警提示（怎样验证合法，下文会详细解析，这里先忽略）

### 数据传输阶段

证书验证合法之后

1. 浏览器会生成一个随机数，
2. 使用公钥进行加密，发送给服务端
3. 服务器收到浏览器发来的值，使用私钥进行解密
4. 解析成功之后，使用对称加密算法进行加密，传输给客户端

之后双方通信就使用第一步生成的随机数进行加密通信。

## https 的加密方式是怎样的，对称加密和非对称加密，为什么要这样设计

从上面我们可以知道，https 加密是采用对称加密和非对称机密一起结合的。

在证书验证阶段，使用非对称加密。 在数据传输阶段，使用对称机密。

这样设计有一个好处，能最大程度得兼顾安全效率。

在证书验证阶段，使用非对称加密，需要公钥和私钥，假如浏览器的公钥泄漏了，我们还是能够确保随机数的安全，因为加密的数据只有用私钥才能解密。这样能最大程度确保随机数的安全。

在内容传输阶段，使用对称机密，可以大大提高加解密的效率。

### 内容传输为什么要使用对称机密

1. 对称加密效率比较高
2. 一对公私钥只能实现单向的加解密。只有服务端保存了私钥。如果使用非对称机密，相当于客户端必须有自己的私钥，这样设计的话，每个客户端都有自己的私钥，这很明显是不合理的，因为私钥是需要申请的。

## https 是绝对安全的吗

不是绝对安全的，可以通过中间人攻击。

### 什么是中间人攻击

中间人攻击是指攻击者与通讯的两端分别创建独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者完全控制。

HTTPS 使用了 SSL 加密协议，是一种非常安全的机制，目前并没有方法直接对这个协议进行攻击，一般都是在建立 SSL 连接时，拦截客户端的请求，利用中间人获取到 CA证书、非对称加密的公钥、对称加密的密钥；有了这些条件，就可以对请求和响应进行拦截和篡改。

[![img](https://raw.githubusercontent.com/gdutxiaoxu/blog_pic/master/20_04/20200708233547.png)](https://raw.githubusercontent.com/gdutxiaoxu/blog_pic/master/20_04/20200708233547.png)

过程原理：

1. 本地请求被劫持（如DNS劫持等），所有请求均发送到中间人的服务器
2. 中间人服务器返回中间人自己的证书
3. 客户端创建随机数，通过中间人证书的公钥对随机数加密后传送给中间人，然后凭随机数构造对称加密对传输内容进行加密传输
4. 中间人因为拥有客户端的随机数，可以通过对称加密算法进行内容解密
5. 中间人以客户端的请求内容再向正规网站发起请求
6. 因为中间人与服务器的通信过程是合法的，正规网站通过建立的安全通道返回加密后的数据
7. 中间人凭借与正规网站建立的对称加密算法对内容进行解密
8. 中间人通过与客户端建立的对称加密算法对正规内容返回的数据进行加密传输
9. 客户端通过与中间人建立的对称加密算法对返回结果数据进行解密

由于缺少对证书的验证，所以客户端虽然发起的是 HTTPS 请求，但客户端完全不知道自己的网络已被拦截，传输内容被中间人全部窃取。

### https 是如何防止中间人攻击的

在https中需要证书，证书的作用是为了防止"中间人攻击"的。 如果有个中间人M拦截客户端请求,然后M向客户端提供自己的公钥，M再向服务端请求公钥,作为"中介者" 这样客户端和服务端都不知道,信息已经被拦截获取了。这时候就需要证明服务端的公钥是正确的.

怎么证明呢?

就需要权威第三方机构来公正了.这个第三方机构就是CA. 也就是说CA是专门对公钥进行认证，进行担保的，也就是专门给公钥做担保的担保公司。 全球知名的CA也就100多个，这些CA都是全球都认可的，比如VeriSign、GlobalSign等，国内知名的CA有WoSign。

### 浏览器是如何确保CA证书的合法性？

一、证书包含什么信息？

颁发机构信息、公钥、公司信息、域名、有效期、指纹......

二、证书的合法性依据是什么？

首先，权威机构是要有认证的，不是随便一个机构都有资格颁发证书，不然也不叫做权威机构。另外，证书的可信性基于信任制，权威机构需要对其颁发的证书进行信用背书，只要是权威机构生成的证书，我们就认为是合法的。所以权威机构会对申请者的信息进行审核，不同等级的权威机构对审核的要求也不一样，于是证书也分为免费的、便宜的和贵的。

三、浏览器如何验证证书的合法性？

浏览器发起HTTPS请求时，服务器会返回网站的SSL证书，浏览器需要对证书做以下验证：

1. 验证域名、有效期等信息是否正确。证书上都有包含这些信息，比较容易完成验证；
2. 判断证书来源是否合法。每份签发证书都可以根据验证链查找到对应的根证书，操作系统、浏览器会在本地存储权威机构的根证书，利用本地根证书可以对对应机构签发证书完成来源验证；
3. 判断证书是否被篡改。需要与CA服务器进行校验；
4. 判断证书是否已吊销。通过CRL（Certificate Revocation List 证书注销列表）和 OCSP（Online Certificate Status Protocol 在线证书状态协议）实现，其中 OCSP 可用于第3步中以减少与CA服务器的交互，提高验证效率。

以上任意一步都满足的情况下浏览器才认为证书是合法的。

## https 可以抓包吗

HTTPS 的数据是加密的，常规下抓包工具代理请求后抓到的包内容是加密状态，无法直接查看。

但是，我们可以通过抓包工具来抓包。它的原理其实是模拟一个中间人。

通常 HTTPS 抓包工具的使用方法是会生成一个证书，用户需要手动把证书安装到客户端中，然后终端发起的所有请求通过该证书完成与抓包工具的交互，然后抓包工具再转发请求到服务器，最后把服务器返回的结果在控制台输出后再返回给终端，从而完成整个请求的闭环。

关于 httpps 抓包的原理可以看这一篇文章。

[Android平台HTTPS抓包解决方案及问题分析](https://juejin.im/post/5cc313755188252d6f11b463)

**有人可能会问了，既然 HTTPS 不能防抓包，那 HTTPS 有什么意义？**

HTTPS 可以防止用户在不知情的情况下通信链路被监听，对于主动授信的抓包操作是不提供防护的，因为这个场景用户是已经对风险知情。要防止被抓包，需要采用应用级的安全防护，例如采用私有的对称加密，同时做好移动端的防反编译加固，防止本地算法被破解。

## 扩展

### 如何防止抓包？

对于HTTPS API接口，如何防止抓包呢？既然问题出在证书信任问题上，那么解决方法就是在我们的APP中预置证书。在TLS/SSL握手时，用预置在本地的证书中的公钥校验服务器的数字签名，只有签名通过才能成功握手。由于数字签名是使用私钥生成的，而私钥只掌握在我们手上，中间人无法伪造一个有效的签名，因此攻击失败，无法抓包。

同时，为了防止预置证书被替换，在证书存储上，可以将证书进行加密后进行「嵌入存储」，如嵌入在图片中或一段语音中。这涉及到信息隐写的领域，这个话题我们有空了详细说。

关于 Android 中Https 请求如何防止中间人攻击和Charles抓包，可以看一下这一篇文章。

[Android中Https请求如何防止中间人攻击和Charles抓包原理](https://www.jianshu.com/p/1dd77e56cc3c)

### 预置证书/公钥更新问题

这样做虽然解决了抓包问题，但是也带来了另外一个问题：我们购买的证书都是有有效期的，到期前需要对证书进行更新。主要有两种方式：

提供预置证书更新接口。在当前证书快过期时，APP请求获取新的预置证书，这过渡时期，两个证书同时有效，直到安全完成证书切换。这种方式有一定的维护成本，且不易测试。 在APP中只预埋公钥，这样只要私钥不变，即使证书更新也不用更新该公钥。但是，这样不太符合周期性更新私钥的安全审计需求。一个折中的方法是，一次性预置多个公钥，只要任意一个公钥验证通过即可。考虑到我们的证书一般购买周期是3-5年，那么3个公钥，可以使用9-15年，同时，我们在此期间还可以发布新版本废弃老公钥，添加新公钥，这样可以使公钥一直更新下去。

------

## 小结

开头说到的几个问题，你能对答如流了吗

1. 什么是 https，为什么需要 https
2. https 的连接过程
3. https 的加密方式是怎样的，对称加密和非对称加密，为什么要这样设计？内容传输为什么要使用对称机密
4. https 是绝对安全的吗
5. https 可以抓包吗





## 面试常见

### 一道经典的面试题

还记得这道经典的面试题目吗？从 URL 在浏览器被被输入到页面展现的过程中发生了什么？

总体来说分为以下几个过程:

- DNS 解析:将域名解析成 IP 地址
- TCP 连接：TCP 三次握手
- 发送 HTTP 请求
- 服务器处理请求并返回 HTTP 报文
- 浏览器解析渲染页面
- 断开连接：TCP 四次挥手

完整的可以看以下下面的图片

[![img](https://raw.githubusercontent.com/gdutxiaoxu/blog_pic/master/20_04/20200713234113.png)](https://raw.githubusercontent.com/gdutxiaoxu/blog_pic/master/20_04/20200713234113.png)

## http 必备基础知识

HTTP 是一种 超文本传输协议(Hypertext Transfer Protocol)，HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范

[![img](https://raw.githubusercontent.com/gdutxiaoxu/blog_pic/master/20_07/20200714212848.png)](https://raw.githubusercontent.com/gdutxiaoxu/blog_pic/master/20_07/20200714212848.png)

HTTP 主要内容分为三部分，超文本（Hypertext）、传输（Transfer）、协议（Protocol）。

- 超文本就是不单单只是本文，它还可以传输图片、音频、视频，甚至点击文字或图片能够进行超链接的跳转。
- 上面这些概念可以统称为数据，传输就是数据需要经过一系列的物理介质从一个端系统传送到另外一个端系统的过程。通常我们把传输数据包的一方称为请求方，把接到二进制数据包的一方称为应答方。
- 而协议指的就是是网络中(包括互联网)传递、管理信息的一些规范。如同人与人之间相互交流是需要遵循一定的规矩一样，计算机之间的相互通信需要共同遵守一定的规则，这些规则就称为协议，只不过是网络协议。

### 什么是无状态协议，HTTP 是无状态协议吗，怎么解决

无状态协议(Stateless Protocol) 就是指浏览器对于事务的处理没有记忆能力。举个例子来说就是比如客户请求获得网页之后关闭浏览器，然后再次启动浏览器，登录该网站，但是服务器并不知道客户关闭了一次浏览器。

HTTP 就是一种无状态的协议，他对用户的操作没有记忆能力。可能大多数用户不相信，他可能觉得每次输入用户名和密码登陆一个网站后，下次登陆就不再重新输入用户名和密码了。这其实不是 HTTP 做的事情，起作用的是一个叫做 小甜饼(Cookie) 的机制。它能够让浏览器具有记忆能力。 如果你的浏览器允许 cookie 的话，查看方式 chrome://settings/content/cookies

### 几种方法

HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法

HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT

- GET: 通常用于请求服务器发送某些资源
- HEAD: 请求资源的头部信息, 并且这些头部与 HTTP GET 方法请求时返回的一致. 该请求方法的一个使用场景是在下载一个大文件前先获取其大小再决定是否要下载, 以此可以节约带宽资源
- OPTIONS: 用于获取目的资源所支持的通信选项
- POST: 发送数据给服务器，是**非幂等**的
- PUT: 跟POST方法很像，也是想服务器提交数据。但是，它们之间有不同。PUT指定了资源在服务器上的位置，而POST不需要置顶资源在服务器的位置，是**幂等**的
- DELETE: 用于删除指定的资源
- PATCH: 用于对资源进行部分修改
- CONNECT: HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器
- TRACE: 回显服务器收到的请求，主要用于测试或诊断

### http get 和 post 区别

| Post一般用于更新或者添加资源信息 | Get一般用于查询操作，而且应该是安全和幂等的 |
| -------------------------------- | ------------------------------------------- |
| Post更加安全                     | Get会把请求的信息放到URL的后面              |
| Post传输量一般无大小限制         | Get不能大于2KB                              |
| Post执行效率低                   | Get执行效率略高                             |

### http put 和 post 区别

**举一个简单的例子**

POST:用于提交请求，可以更新或者创建资源，是非幂等的

举个例子，在我们的支付系统中，一个api的功能是创建收款金额二维码，它和金额相关，每个用户可以有多个二维码，如果连续调用则会创建新的二维码，这个时候就用POST

PUT: 用于向指定的URI传送更新资源，是幂等的

还是那个例子，用户的账户二维码只和用户关联，而且是一一对应的关系，此时这个api就可以用PUT，因为每次调用它，都将刷新用户账户二维码

**如果从 RESTful API 的角度来理解，PUT 方法是这么工作的：**

把一个对象 V 绑定到地址 K 上；今后请求地址 K 时，就会返回对象 V。

如果地址 K 之前曾绑定过另一个对象，比如 V0，那么 V0 会被 V 替换。

举一个简单的例子，假设我的博客后台支持 RESTful API，我可以通过下面的请求发布这篇文章：

```
PUT https://gdutxiao.github.io/2018/04/16/http-put-vs-post HTTP/1.1

{
    /* 文章内容正文 */
}
```

可以看出，使用 PUT 方法时，客户端需要在 HTTP 请求中明确指定地址 K。

正如 Java 的例子一样，PUT 方法应当支持幂等性。如果是同一个对象 V，PUT 多次与 PUT 一次返回的结果应该是相同的。客户端可以利用 PUT 的幂等性安全地重试请求，保证客户端的请求至少被服务端处理一次。

如果把上面发布文章的例子用 HTTP POST 方法重写，它可能会是下面这样：

```
POST https://gdutxiao.github.io/post-article HTTP/1.1

{
    /* 文章内容正文 */
}
```

也就是说，地址 K 不是由客户端指定的，而是由服务端生成的。比如，服务端可能会根据日期和文章标题，为本文分配一个地址。

另外，与 PUT 方法不同，POST 方法是不支持幂等性的。同一个请求被处理两次，应当生成两份对象。换句话说，客户端应该只发送一次 POST 请求，而客户端的请求至多会被服务端处理一次。

> 现在问题来了，如果真的遇到了网络故障，客户端应该如何重试 POST 请求呢？解决方法其实很简单，我们可以在 POST 请求中隐藏一个唯一的 token，服务端在处理请求后把 token 存入数据库，如果这个 token 之前遇到过，服务端就知道这是重复的 POST 请求，可以不再处理了。

## http 版本

### 1.0 与 1.1

- http1.0一次只能处理一个请求，不能同时收发数据
- http1.1可以处理多个请求，能同时收发数据
- http1.1增加可更多字段，如cache-control,keep-alive.

### 2.0

- http 2.0采用二进制的格式传送数据，不再使用文本格式传送数据
- http2.0对消息头采用hpack压缩算法，http1.x的版本消息头带有大量的冗余消息
- http2.0 采用多路复用，即用一个tcp连接处理所有的请求，真正意义上做到了并发请求，流还支持优先级和流量控制（HTTP/1.x 虽然通过 pipeline也能并发请求，但是多个请求之间的响应会被阻塞的，所以 pipeline 至今也没有被普及应用，而 HTTP/2 做到了真正的并发请求。同时，流还支持优先级和流量控制。）
- http2.0支持server push，服务端可以主动把css，jsp文件主动推送到客户端，不需要客户端解析HTML，再发送请求，当客户端需要的时候，它已经在客户端了。

**缺点**

虽然 HTTP/2 解决了很多之前旧版本的问题，但是它还是存在一个巨大的问题， **主要是底层支撑的 TCP 协议造成的** 。HTTP/2的缺点主要有以下几点：

- TCP 以及 TCP+TLS建立连接的延时

HTTP/2使用TCP协议来传输的，而如果使用HTTPS的话，还需要使用TLS协议进行安全传输，而使用TLS也需要一个握手过程， **这样就需要有两个握手延迟过程** ：

①在建立TCP连接的时候，需要和服务器进行三次握手来确认连接成功，也就是说需要在消耗完1.5个RTT之后才能进行数据传输。

②进行TLS连接，TLS有两个版本——TLS1.2和TLS1.3，每个版本建立连接所花的时间不同，大致是需要1~2个RTT。

总之，在传输数据之前，我们需要花掉 3～4 个 RTT。

- TCP的队头阻塞并没有彻底解决

上文我们提到在HTTP/2中，多个请求是跑在一个TCP管道中的。但当出现了丢包时，HTTP/2 的表现反倒不如 HTTP/1 了。因为TCP为了保证可靠传输，有个特别的“丢包重传”机制，丢失的包必须要等待重新传输确认，HTTP/2出现丢包时，整个 TCP 都要开始等待重传，那么就会阻塞该TCP连接中的所有请求（如下图）。而对于 HTTP/1.1 来说，可以开启多个 TCP 连接，出现这种情况反到只会影响其中一个连接，剩余的 TCP 连接还可以正常传输数据。

[![img](https://raw.githubusercontent.com/gdutxiaoxu/blog_pic/master/20_04/20200714205644.png)](https://raw.githubusercontent.com/gdutxiaoxu/blog_pic/master/20_04/20200714205644.png)

### Http 3.0

Google 在推SPDY的时候就已经意识到了这些问题，于是就另起炉灶搞了一个基于 UDP 协议的“QUIC”协议，让HTTP跑在QUIC上而不是TCP上。 而这个“HTTP over QUIC”就是HTTP协议的下一个大版本，HTTP/3。它在HTTP/2的基础上又实现了质的飞跃，真正“完美”地解决了“队头阻塞”问题。

[![img](https://raw.githubusercontent.com/gdutxiaoxu/blog_pic/master/20_04/20200714210054.png)](https://raw.githubusercontent.com/gdutxiaoxu/blog_pic/master/20_04/20200714210054.png)

QUIC 虽然基于 UDP，但是在原本的基础上新增了很多功能，接下来我们重点介绍几个QUIC新功能。不过HTTP/3目前还处于草案阶段，正式发布前可能会有变动，所以本文尽量不涉及那些不稳定的细节。

#### QUIC新功能

上面我们提到QUIC基于UDP，而UDP是“无连接”的，根本就不需要“握手”和“挥手”，所以就比TCP来得快。此外QUIC也实现了可靠传输，保证数据一定能够抵达目的地。它还引入了类似HTTP/2的“流”和“多路复用”，单个“流"是有序的，可能会因为丢包而阻塞，但其他“流”不会受到影响。具体来说QUIC协议有以下特点：

- 实现了类似TCP的流量控制、传输可靠性的功能。

虽然UDP不提供可靠性的传输，但QUIC在UDP的基础之上增加了一层来保证数据可靠性传输。它提供了数据包重传、拥塞控制以及其他一些TCP中存在的特性。

- 实现了快速握手功能。

由于QUIC是基于UDP的，所以QUIC可以实现使用0-RTT或者1-RTT来建立连接，这意味着QUIC可以用最快的速度来发送和接收数据，这样可以大大提升首次打开页面的速度。 **0RTT 建连可以说是 QUIC 相比 HTTP2 最大的性能优势** 。

- 集成了TLS加密功能。

目前QUIC使用的是TLS1.3，相较于早期版本TLS1.3有更多的优点，其中最重要的一点是减少了握手所花费的RTT个数。

- 多路复用，彻底解决TCP中队头阻塞的问题

和TCP不同，QUIC实现了在同一物理连接上可以有多个独立的逻辑数据流（如下图）。实现了数据流的单独传输，就解决了TCP中队头阻塞的问题。

[![img](https://raw.githubusercontent.com/gdutxiaoxu/blog_pic/master/20_04/20200714210232.png)](https://raw.githubusercontent.com/gdutxiaoxu/blog_pic/master/20_04/20200714210232.png)

关于 http 3.0 的，如果想了解更多，可以查看这一篇文章。[解密HTTP/2与HTTP/3 的新特性](https://juejin.im/post/5d9abde7e51d4578110dc77f)

### 总结

- HTTP/1.1有两个主要的缺点：安全不足和性能不高。
- HTTP/2完全兼容HTTP/1，是“更安全的HTTP、更快的HTTPS"，头部压缩、多路复用等技术可以充分利用带宽，降低延迟，从而大幅度提高上网体验；
- QUIC 基于 UDP 实现，是 HTTP/3 中的底层支撑协议，该协议基于 UDP，又取了 TCP 中的精华，实现了即快又可靠的协议

## http 状态码

| Http 状态码 | 含义                                                     |
| ----------- | -------------------------------------------------------- |
| 200         | 请求成功                                                 |
| 206         | 支持断点下载（range = byte = 0 -1024)                    |
| 301         | 永远移动                                                 |
| 302         | 临时移动                                                 |
| 303         | See Other 查看其它地址。与301类似。使用GET和POST请求查看 |
| 304         | 无更新                                                   |
| 400         | Bad request,服务器无法识别                               |
| 403         | 禁止访问                                                 |
| 404         | not found                                                |
| 405         | Method Not Allowed 客户端请求中的方法被禁止              |
| 500         | Internal Server Error 服务器内部错误，无法完成请求       |

关于更详细的可以查看

[http 状态码](https://www.runoob.com/http/http-status-codes.html)

## 参考链接

https://juejin.im/post/5d032b77e51d45777a126183

https://www.cnblogs.com/geass-jango/p/11458549.html

https://zhuanlan.zhihu.com/p/135947893

https://www.v2ex.com/t/373770

https://www.jianshu.com/p/f6b0cc69affc



#### 计算机网络基本知识

HTTP协议（超文本传输协议）和 UDP（用户数据包协议），TCP 协议（传输控制协议）

TCP/IP是个协议组，可分为四个层次：网络接口层、网络层、传输层和应用层。 在网络层有IP协议、ICMP协议、ARP协议、RARP协议和BOOTP协议。 在传输层中有TCP协议与UDP协议，arq协议。 在应用层有FTP、HTTP、TELNET、SMTP、DNS等协议。

[![enter description here](https://camo.githubusercontent.com/ac27dd052dd800d61c8ca544f7148a0dcaa036c3903c4e398d1cdaa40235f3e5/68747470733a2f2f696d67636f6e766572742e6373646e696d672e636e2f6148523063484d364c7939316347787659575174615731685a32567a4c6d70705957357a6148557561573876645842736232466b58326c745957646c637938794d4455774d6a417a4c574d7a5a6a63334d6d49354e5455774d47526d4d7a67756347356e)](https://camo.githubusercontent.com/ac27dd052dd800d61c8ca544f7148a0dcaa036c3903c4e398d1cdaa40235f3e5/68747470733a2f2f696d67636f6e766572742e6373646e696d672e636e2f6148523063484d364c7939316347787659575174615731685a32567a4c6d70705957357a6148557561573876645842736232466b58326c745957646c637938794d4455774d6a417a4c574d7a5a6a63334d6d49354e5455774d47526d4d7a67756347356e)

## TCP 与 UDP

### TCP与UDP基本区别

[![enter description here](https://camo.githubusercontent.com/a1711b58cbc59d18d171bf31641e7da6b300ebcd4b0ee66c60be4da3a6c6a739/68747470733a2f2f696d67636f6e766572742e6373646e696d672e636e2f6148523063484d364c7939316347787659575174615731685a32567a4c6d70705957357a6148557561573876645842736232466b58326c745957646c637938794d4455774d6a417a4c544d344f4451344e6a4d775a47466d4d6a4a6d4e6a4d756347356e)](https://camo.githubusercontent.com/a1711b58cbc59d18d171bf31641e7da6b300ebcd4b0ee66c60be4da3a6c6a739/68747470733a2f2f696d67636f6e766572742e6373646e696d672e636e2f6148523063484d364c7939316347787659575174615731685a32567a4c6d70705957357a6148557561573876645842736232466b58326c745957646c637938794d4455774d6a417a4c544d344f4451344e6a4d775a47466d4d6a4a6d4e6a4d756347356e)

UDP与TCP的区别与联系

一：UDP是面向无连接的协议，TCP 是面向连接的协议 UDP发出请求后，即发送数据之前不需要先连接，TCP 发送数据之前需要先连接 二：UDP 相对TCP来说是不可靠的 因为 UDP 在发送数据以后，没有采用超时重发，停止等待机制，拥塞控制 三：TCP 面向流，UDP 面向报文

### TCP优缺点：

优点：可靠，稳定

TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源。

缺点：

- 慢，效率低，占用系统资源高，易被攻击 TCP在传递数据之前，要先建连接，这会消耗时间，而且在数据传递时，确认机制、重传机制、拥塞控制机制等都会消耗大量的时间，而且要在每台设备上维护所有的传输连接，事实上，每个连接都会占用系统的CPU、内存等硬件资源。
- 而且，因为TCP有确认机制、三次握手机制，这些也导致TCP容易被人利用，实现DOS、DDOS、CC等攻击。

### UDP优缺点：

优点：

- 快，比TCP稍安全
- UDP没有TCP的握手、确认、窗口、重传、拥塞控制等机制，UDP是一个无状态的传输协议，所以它在传递数据时非常快。没有TCP的这些机制，UDP较TCP被攻击者利用的漏洞就要少一些。但UDP也是无法避免攻击的，比如：UDP Flood攻击……

缺点：

- 不可靠，不稳定 。因为UDP没有TCP那些可靠的机制，在数据传递时，如果网络质量不好，就会很容易丢包。

　　

### 三次握手与四次挥手

**三次握手**

第一次握手:第一次连接时，客户端向服务器端发送SYN（syn=j），等待服务器端的确认，此时客户端进入SYN_SEND状态，SYN：同步序列号

第二次握手：服务器端收到客户端发来的SYN，必须向客户端发送ACK包（ack=j+1=k），同时自己必须发送一个SYN包，即syn+ack，此时进入SYN_REC状态

第三次握手：客户端收到服务器端发来的syn+ack包，向服务器发送ack包（ack=k+1),发送完毕，此时进入ESTABLISH状态，连接成功，完成第三次连接。

```
发送                  确认


第一次：SYN=1       SEQ=X               ACK=0（客）
第二次：SYN=1       SEQ=Y               ACK=X+1（服）
第三次：            SEQ=X+1             ACK=Y+1（客）
```

**4次挥手**

1. 当主机A完成数据传输后,将控制位FIN置1,提出停止TCP连接的请求 A进入终止等待1（FIN-WAIT-1）状态
2. 主机B收到FIN后对其作出响应,确认这一方向上的TCP连接将关闭,将ACK置1 tcp处于半关闭状态（half-close） a收到b端的确认后，就进入终止等待2状态
3. 由B 端再提出反方向的关闭请求,将FIN置1 进入last-wait状态
4. 主机A对主机B的请求进行确认,将ACK置1,双方向的关闭结束. 进入时间等待状态（time-wait） 时间等待计数器设置的时间过了2msl以后，进入closed状态

**三次握手的原因**

如果只有两次握手的话，比如说失效的报文段，突然发送到服务端，服务端收到失效报文段的请求后，会发送确认报文，新的连接就建立起来了。但现在由于客户端并没有发出请求，所以并不会理睬服务端的确认，也不会像服务端发送数据。而服务端以为已经连接起来了，一直在等待，浪费资源。

**四次挥手的原因**

TCP建立连接要进行3次握手,而断开连接要进行4次,这是由于TCP的半关闭造成的,因为TCP连接是全双工的( 即数据可在两个方向上同时传递)所以进行关闭时每个方向上都要单独进行关闭,这个单方向的关闭就叫半关闭.

关闭的方法是一方完成它的数据传输后,就发送一个FIN来向另一方通告将要终止这个方向的连接.当一端收到一个FIN,它必须 通知应用层TCP连接已终止了这个方向的数据传送,发送FIN通常是应用层进行关闭的结果.

### 名词解释

ACK TCP报头的控制位之一,对数据进行确认.确认由目的端发出,用它来告诉发送端这个序列号之前的数据段 都收到了.比如,确认号为X,则表示前X-1个数据段都收到了,只有当ACK=1时,确认号才有效,当ACK=0时,确认号无效,这时会要求重传数据,保证数据的完整性. SYN 同步序列号,TCP建立连接时将这个位置1 FIN 发送端完成发送任务位,当TCP完成数据传输需要断开时,提出断开连接的一方将这位置1

------

## Http 与 https

Http 是在应用层上的传输协议，底层是 TCP 协议实现的， 它一种面向无状态的连接，短连接， 之所以说他无状态，是因为在每一次请求完成之后，都会把连接关了，不会记住是哪一个客户端连接。

**四种请求方式** get，post，pull，delete

**请求信息有请求行，请求头，请求正文**

请求行：请求方式，请求地址，请求协议 请求头：头名称，头值 请求正文：（只有post请求才会有）

**响应信息有相应行，响应头，响应正文**

响应行：响应协议，状态码，状态信息 响应 头：头名称和头值 响应正文

### Http1.0与Http1.1，Http2.0的区别

http 2.0采用二进制的格式传送数据，不再使用文本格式传送数据 http2.0对消息头采用hpack压缩算法，http1.x的版本消息头带有大量的冗余消息 http2.0 采用多路复用，即用一个tcp连接处理所有的请求，真正意义上做到了并发请求，流还支持优先级和流量控制 http2.0支持server push，服务端可以主动把css，jsp文件主动推送到客户端，不需要客户端解析HTML，再发送请求，当客户端需要的时候，它已经在客户端了。

- Http1.0一次只能处理一个请求和响应，Http1.1一次能处理多个请求和响应
- 多个请求和响应过程可以重叠
- 增加了更多的请求头和响应头，比如Host、If-Unmodified-Since请求头等

### http和https的区别

https相当于http加上安全套接字，采用ssl加密技术

主要的区别

1. 在osi模型中，http工作于应用层，https工作与传输层
2. http传输的时候采用明文传输，https采用加密传输
3. http不需要证书，https需要响应额证书
4. http以http开头，默认端口是80，https 以https开头，默认的端口是243

上传视频的时候为什么不用 Http 协议？

因为上传视频的时候文件一般比较长，如果我们采用 post 请求的话，写到输出流中，它并不会直接写到服务器中，而是会缓存在内存中，会影响我们的执行效率

------

## 扩展补充

停止等待机制：是指每发送完一个分组，就会停止发送，必须受到对这个分组的确认才会继续发送下一个分组

超时重传：是指每发送一个分组，就会为这个分组启动一个超时计数器，在规定的时间内没有受到确认，就会再次发送这个分组。

在连续ARQ协议中，为提高信道利用率，通常采取的做法是发送方维持一个发送窗口，凡是位于该窗口内的分组都可以发送出去，无需等待确认，在接收方是采用累积确认，即对按需到达的分组后一个分组发送确认，表明在这个分组以前的所有分组都已正确接收到

拥塞控制与流量控制

流量控制是一个端到端的过程，是值接收方限制发送方的速率不要太快，使接收方来得及接收；拥塞控制是一个全局的过程，是只不要向网络注入太多的数据，导致链路或者路由器损坏；

拥塞控制采用四种算法：慢开始和拥塞控制，快重传和快恢复

慢开始是cwnd（拥塞窗口）每次回从1开始，每经过一个往返时间，cwnd的值就会加倍； 拥塞避免是指每经过一个往返时间，cwnd的值会加一，是一个线性的过程。 慢开始和拥塞避免:会设置一个慢开始门限，当cwnd《sshreh的时候，会采用满开始算法，当超过这个值的时候，会采用拥塞避免的算法，当出现拥塞的时候，会把sshreh的值取为发送方窗口值当前的一半，再把cwnd取为1，从1开始使用满开始算法。

快重传和快恢复收到三个重复确认的时候，会把sshreh的值置为当前值的一半，与慢开始不同的是，它会把拥塞窗口的值取为当前慢开始门限的一半，执行拥塞避免算法

快重传要求接收方没收到一段失序的报文段，就要向发送方发送一个确认

**洪水攻击**

向服务器端发送大量的伪TCP连接请求，这时候服务器端会进入syn_receive半连接状态，服务器端会尝试发送多次包来确认，因为这些连接时假冒的，所以并不会完成第三次握手，导致服务器端保持大量的半连接状态，耗费资源，是TCP连接队列被塞满。

解决方法：

1. 做一些应急处理，对这些IP地址的特征来禁止响应的IP地址字段的访问。
2. 应急处理毕竟太被动，因为本机房的F5比较空闲，运维利用F5来挡攻击，采用方式：让客户端先和F5三次握手，连接建立之后F5才转发到后端业务服务器。